
ğŸ§ª Failed Attempts & Debug Notes (for Portfolio Transparency)

Throughout the Rhomaleosaurus rigging and Unity integration process, several failed attempts were made before arriving at a successful export and animation. These are documented here for transparency and to help other learners facing similar challenges.

ğŸ§¼ Unity Import Errors

At one point after re-exporting the .fbx file from Blender and importing it into Unity, a warning appeared in the console:

â€œMissing Prefab Asset: rhomaleosaurus_high 1 Variant (Missing Prefab with GUID...)â€

This warning initially caused concern. It appeared because Unity was looking for an old prefab variant that had been deleted or renamed. After reviewing the file structure, it was confirmed that this error had no impact on functionality â€” the imported .fbx and animation played as expected.

Takeaway: Unity sometimes retains references to deleted prefabs. As long as your mesh, bones, and animation work properly, this warning can be safely ignored.

ğŸ¦· Detached Eyes and Teeth

A key issue was that the eyes and teeth did not animate with the rest of the Rhomaleosaurus body in Unity. Even after:

Joining the eyes and teeth to the main mesh using Ctrl + J

Parenting the mesh to the armature with automatic weights

Confirming the eyes/teeth were part of the geometry in Blender

â€¦the eyes and teeth remained static during animation playback.

Further inspection revealed that the joined parts were not properly weight painted. They had not been assigned to any bone or vertex group and thus remained unaffected during movement.

An attempt was made to correct this by entering Edit Mode, selecting the detached geometry, and using Merge by Distance. This merged the mesh geometrically, but did not automatically assign bone weights. The animation still excluded them.

Takeaway: Joining mesh parts isnâ€™t enough. Without vertex weight assignment or manual painting, additional geometry wonâ€™t respond to armature animations. These parts must be properly bound to the correct joints.

ğŸŒ€ Blender Modifier Chaos

Upon reviewing the modifiers tab, there were multiple armature modifiers stacked onto the main mesh (e.g., Armature, Armature.001, Armature.002, etc.). This often happens after importing models with nested skeletons or duplicate rigs.

Initially, this caused confusion, as it was unclear which modifier was actually driving the animation. The fix was to delete all but the correct Armature modifier (in this case, Armature.001), clean up the vertex group associations, and reapply the weights.

Takeaway: Keep only one armature modifier on the mesh to avoid conflicts. Clean up extra modifiers as early as possible.

ğŸ§© Misleading Vertex Group Names

The vertex groups were auto-generated from the animation rig and named in a non-intuitive format (joint1_01, joint6_012, etc.). When troubleshooting why certain parts werenâ€™t moving, it wasnâ€™t immediately clear which bone controlled which part of the mesh.

Weight painting each group revealed which joints affected which areas, but this process was time-consuming.

Takeaway: If possible, rename bones and vertex groups for clarity before export. It greatly simplifies debugging and future edits.

ğŸ¢ Timeline Confusion in Blender

During one part of the process, Pose Mode was entered in Blender, but pressing "Play" didnâ€™t seem to animate the rig. The Timeline and Dope Sheet were not visible. This created the false impression that the animation was broken.

Eventually, it was discovered that the Timeline panel needed to be reopened via the bottom editor window selector, and the range of frames (1 to 250) adjusted correctly. Once done, the animation played as intended.

Takeaway: Blender's layout can sometimes hide essential editors. If animation playback doesnâ€™t work, always check that the Timeline is visible and correctly configured.

ğŸ˜®â€ğŸ’¨ â€œCtrl + Pâ€ False Sense of Success

After completing the join and parenting process (using Ctrl + P â†’ With Automatic Weights), it appeared everything was bound correctly. The export was saved and brought into Unity.

But once inside Unity, the eyes and teeth were still unresponsive.

Turns out, applying automatic weights after joining geometry is not enough unless weight painting is verified for every mesh part. Some parts simply wonâ€™t inherit weights properly and must be assigned manually or through weight transfer.

Takeaway: Always double-check weight painting, especially after joining objects. Blender doesn't always auto-assign weights as expected.

ğŸ§  Final Thoughts on Transparency

This project involved a high degree of trial and error, especially around:

Rig cleanup

Modifier simplification

Binding geometry with armatures

Weight painting subtleties

Unity prefab and import errors

These failed attempts were not setbacks â€” they were essential learning moments. They taught a deeper understanding of Blenderâ€™s rigging system, Unityâ€™s import pipeline, and how 3D pipelines behave when importing legacy assets or repairing older models.

You are encouraged to keep these kinds of notes in your own workflow â€” they not only build technical resilience, they show future collaborators and employers your ability to debug, problem-solve, and persevere.