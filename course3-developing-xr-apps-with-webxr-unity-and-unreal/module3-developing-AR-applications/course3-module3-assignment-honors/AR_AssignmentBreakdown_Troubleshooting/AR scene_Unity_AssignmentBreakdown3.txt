
ğŸ¦– Tutorial: Troubleshooting Unity Animation + Final Transition to A-Frame (Rhomaleosaurus AR Scene)
ğŸ¯ Project Goal

This project aimed to animate a Rhomaleosaurus skeleton in an augmented reality (AR) scene using Unity. The vision was to bring the creature to life with a looping swim animation that would eventually be deployed in AR using Unityâ€™s AR Foundation or WebXR options. What initially worked during earlier experiments in Unity 6000 failed during later attempts â€” leading to a creative pivot to A-Frame for a lighter, more stable implementation.

ğŸ› ï¸ Setup

Model: Dino_SPOOKY_SKELETON.fbx (rigged and animated in Blender)

Animation: Object_4|SwimmingBiting

Animator Controller: DinoSwim_Controller (created in Unity)

Scene: Dino_AR_2SPOOKY (new Unity scene built from scratch)

Unity Versions Tested:

Unity 6000 (where original animation had worked once)

Unity 2022.3.6f2 LTS (used for reliability moving forward)

â— What Went Wrong in Unity

Despite setting everything up correctly â€” assigning the controller, confirming animation clips, checking the avatar setup â€” the dinosaur would not swim in Unity during playback. The model would appear in the scene, but there was no movement at all. Several visual bugs appeared or persisted during this process, such as misaligned teeth or eyes, but the primary issue was animation failure.

ğŸ”„ Troubleshooting Attempted (Unity)

Over the course of the session, the following steps were taken:

Confirmed Animation Import

Animation was visible in the Rig > Animation tab of the model inspector.

Object_4|SwimmingBiting clip had a valid timeline and keyframes.

Verified Animator Setup

Animator component was correctly linked to DinoSwim_Controller.

Avatar was set to Dino_SPOOKY_SKELETONAvatar.

Update mode set to â€œNormalâ€ with â€œApply Root Motionâ€ enabled.

Checked Animation Controller

The base layer included the swimming animation.

Transition arrow connected from Entry node.

Animation was set to loop and playback speed was set to 1.

Scene Debugging

Play mode tested from multiple camera angles.

Dino was centered at 0, 0, 0 in transform.

Lights and shadows were adjusted â€” still no movement.

Reimport Attempts

Reimported FBX multiple times.

Tried deleting and recreating animator controller.

Attempted creating prefab variants with/without teeth/eyes.

Alternate Unity Version Testing

Unity 6000 (initial version where animation did work once)

Unity 2022.3 (most stable LTS release)

Exported projects and re-imported into both â€” animation still broken.

Other Fixes Attempted

Tried dragging animation clip directly onto Armature.

Applied model import settings again from scratch.

Created transitions, new state names, and adjusted controller values.

Verified "Auto Live Link" and updated playback window.

Despite trying every known animation setup trick, nothing resolved the silent failure of playback. The animator recognized the clip (537 curves were visible), but no motion played out in scene view or Game view.

ğŸ¤” Theories Considered

Unityâ€™s FBX importer may have stripped or misread some animation data.

Animator might have glitched due to prefab or avatar mismatch.

The separate teeth and eyes meshes might be interfering.

Unity versions might be silently breaking compatibility for baked rigs.

Unityâ€™s AR Foundation packages are too complex for current goals.

No single theory could explain why the original animation worked once â€” and then never again â€” even with the exact same files reimported.

ğŸ’¡ Alternative Idea: Use an MP4?

For a moment, the idea of importing an MP4 video of the swim cycle (recorded earlier using Unity Recorder) was considered. However, this approach would prevent mesh or material-level edits â€” like removing the eyes and teeth. Plus, using a flat video in 3D space doesnâ€™t offer interactivity or depth, and isnâ€™t ideal for immersive AR scenes.

ğŸª„ Final Pivot: A-Frame to the Rescue

Rather than continue battling Unity, I pivoted to using A-Frame, a lightweight, web-based XR framework. And the result? Instant success.

Hereâ€™s what happened in A-Frame:

Loaded the .glb model using <a-entity gltf-model="path/to/model.glb">.

The model animated perfectly on load â€” the swim loop played as expected.

No errors. No missing packages. No teeth or eye issues.

Scene ran smoothly in a browser (localhost:8000) using Visual Studio Code + Live Server.

Lighting and camera positioning were easily controlled in HTML.

âœ… Final Decision: A-Frame as AR Scene Platform

Why A-Frame won:

The model worked immediately and correctly with no animation bugs.

A-Frame supports AR out of the box using WebXR and 8thWall/AR.js if needed.

Scene is easy to host and deploy via web or mobile.

File size, lighting, and performance are easier to control.

No package manager errors or Unity animation black holes.

ğŸ§  Lessons Learned

Even with the best planning, not all tools cooperate â€” and that's okay.

A working MVP (Minimum Viable Prototype) is better than a broken ideal.

Unity is powerful, but A-Frame may be better for lightweight AR use cases.

Keep a separate backup of Blender files and multiple FBX versions.

Save screenshots and document errors in real-time for GitHub transparency.

ğŸ”® What Iâ€™d Try Again (If Needed)

Re-rig from scratch with minimal bones for Unity import.

Convert .glb directly to .prefab inside Unity via intermediary tools.

Test Unity 2021.3 LTS instead of 2022/6000 series.

Use Unity Timeline or Animator override controller.

Upload A-Frame version to Glitch, GitHub Pages, or Netlify for instant AR deployment.

ğŸ“ Next Steps

This tutorial serves as both documentation and a postmortem report on what worked, what didnâ€™t, and why we pivoted platforms. If youâ€™re reading this and facing similar Unity animation issues â€” consider trying A-Frame sooner rather than later.

Animation is more than just code â€” itâ€™s collaboration between tools. And sometimes, switching the tool is the best move you can make.